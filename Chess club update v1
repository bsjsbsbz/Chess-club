--[[
    Advanced Chess Bot - Version 4.0
    
    This script is an advanced auto-player (bot) for a Roblox chess game.
    It focuses on providing a strong, yet human-like, playing style to avoid detection.

    Features:
    - Multiple Engine Support: Uses external Stockfish APIs with a fallback to a local engine.
    - Human-like Behavior Simulation:
        - Variable thinking times based on game phase.
        - Intelligent Mistake Simulation: Can play sub-optimal moves based on a probability model.
        - Opening Book: Uses a small opening book for more natural opening play.
        - Stealth Features: Simulates mouse movement, idle time, and uses disguised network requests.
    - Customizable UI:
        - Control over API engine strength (depth and thinking time).
        - Toggles for various stealth and behavior settings.
        - Session statistics tracking (wins, moves, errors, uptime).
]]

local function ChessClubStealth()
    repeat task.wait() until game:IsLoaded()
    
    if game.PlaceId ~= 139394516128799 then return end
    
    -- Obfuscated HTTP request to avoid detection
    local httpReq = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
    if not httpReq then return end
    
    local HttpService = game:GetService("HttpService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage") 
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    
    -- Human behavior simulation data (with reduced delays for better responsiveness)
    local HumanBehavior = {
        ThinkingTimes = {
            Opening = {min = 0.5, max = 2, avg = 1.2},
            Middlegame = {min = 1, max = 4, avg = 2.5},
            Endgame = {min = 0.5, max = 3, avg = 1.8},
            Critical = {min = 2, max = 6, avg = 4.0}
        },
        MoveProbabilities = {
            Perfect = 0.15,
            Excellent = 0.25,
            Good = 0.35,
            Inaccuracy = 0.20,
            Mistake = 0.05
        },
        MousePatterns = {},
        KeyboardActivity = false,
        LastActivity = tick(),
        GamePhase = "opening"
    }
    
    -- A simple opening book to make play more natural.
    -- Maps FEN strings to a list of possible moves.
    local OpeningBook = {
        ["rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"] = {"e2e4", "d2d4", "g1f3", "c2c4"}, -- Starting position
        ["rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq - 0 1"] = {"c7c5", "e7e5", "e7e6", "c7c6"}, -- After 1. e4
        ["rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq - 0 1"] = {"g8f6", "d7d5", "e7e6"}, -- After 1. d4
    }

    -- Enhanced stealth configuration
    local StealthConfig = {
        RandomizeDelay = true,
        SimulateThinking = true,
        AddInaccuracies = true,
        FakeMouseMovement = true,
        UseOpeningBook = true,
        VariableTiming = true,
        AntiPatternDetection = true,
        ObfuscateRequests = true
    }
    
    -- Clean setup with obfuscated names
    local function CleanupConnections(conns)
        for k, v in pairs(conns or {}) do
            if v and typeof(v) == "RBXScriptConnection" then
                pcall(function() v:Disconnect() end)
                conns[k] = nil
            end
        end
    end
    
    if getgenv()._ChessData then
        CleanupConnections(getgenv()._ChessData.Conns)
    end
    
    -- Global storage for session data
    getgenv()._ChessData = {
        Ver = "4.0",
        Engines = {"SF17", "SF16", "LC", "Local"},
        Conns = {},
        Metrics = {moves = 0, wins = 0, errors = 0, start = tick()},
        Cache = {fen = "", move = "", time = 0},
        Behavior = HumanBehavior,
        Stealth = StealthConfig
    }
    
    -- Global settings for the bot
    getgenv()._ChessOpts = {
        active = false,
        engine = "SF17",
        delay = 0.8,
        cache = true,
        debug = false,
        stealth = true,
        apiDepth = 14, -- Engine search depth for API calls
        apiTime = 50   -- Max thinking time in ms for API calls
    }
    
    -- Human-like timing simulation
    local function GetHumanDelay(moveType, gamePhase)
        local config = HumanBehavior.ThinkingTimes[gamePhase] or HumanBehavior.ThinkingTimes.Middlegame
        local base = math.random(config.min * 10, config.max * 10) / 10
        local variation = (math.random(-20, 20) / 100) * base
        local finalDelay = base + variation
        if moveType == "critical" then
            finalDelay = finalDelay * (1.2 + math.random() * 0.6)
        end
        return math.max(1.5, finalDelay)
    end
    
    -- Simulate human mouse activity
    local function SimulateMouseActivity()
        if not StealthConfig.FakeMouseMovement then return end
        task.spawn(function()
            for i = 1, math.random(2, 5) do
                task.wait(math.random(50, 200) / 1000)
            end
        end)
    end
    
    -- Selects a move based on the human simulation settings.
    -- Can choose a sub-optimal move to simulate mistakes.
    local function EvaluateMove(moves)
        if not StealthConfig.AddInaccuracies or not moves or #moves == 0 then
            local move = moves and moves[1] or nil
            if move and type(move) == "string" and #move >= 4 then
                return move:sub(1, 2), move:sub(3, 4), "perfect"
            end
            if type(moves) == "string" and #moves >= 4 then
                return moves:sub(1,2), moves:sub(3,4), "perfect"
            end
            return nil, nil, "perfect"
        end

        local roll = math.random()
        local move
        local moveQuality

        if roll < HumanBehavior.MoveProbabilities.Mistake then
            moveQuality = "mistake"
            move = moves[math.min(#moves, 3)] -- Choose the 3rd best move
        elseif roll < HumanBehavior.MoveProbabilities.Mistake + HumanBehavior.MoveProbabilities.Inaccuracy then
            moveQuality = "inaccuracy"
            move = moves[math.min(#moves, 2)] -- Choose the 2nd best move
        else
            moveQuality = "good"
            move = moves[1] -- Choose the best move
        end

        if move and type(move) == "string" and #move >= 4 then
            return move:sub(1, 2), move:sub(3, 4), moveQuality
        end
        
        return nil, nil, "error"
    end
    
    -- Fetches the best move from the appropriate source (opening book, API, or local engine).
    local function GetBestMove(engine)
        local selected = engine or getgenv()._ChessOpts.engine
        
        local success, tableset = pcall(function()
            return ReplicatedStorage.InternalClientEvents.GetActiveTableset:Invoke()
        end)
        
        if not success or not tableset then return nil end
        
        local FEN = tableset:WaitForChild("FEN", 3)
        if not FEN then return nil end
        
        local fenValue = FEN.Value
        
        -- 1. Check opening book first for common positions
        if StealthConfig.UseOpeningBook and OpeningBook[fenValue] then
            local moves = OpeningBook[fenValue]
            local move = moves[math.random(1, #moves)]
            if move and #move >= 4 then
                return move:sub(1, 2), move:sub(3, 4)
            end
        end

        -- Determine game phase for realistic timing
        local moveCount = select(2, fenValue:gsub("%S+", ""))
        if moveCount < 20 then
            HumanBehavior.GamePhase = "opening"
        elseif moveCount < 40 then  
            HumanBehavior.GamePhase = "middlegame"
        else
            HumanBehavior.GamePhase = "endgame"
        end
        
        -- 2. Check cache for recently calculated moves
        if getgenv()._ChessOpts.cache and getgenv()._ChessData.Cache.fen == fenValue and tick() - getgenv()._ChessData.Cache.time < 25 then
            task.wait(math.random(50, 300) / 1000)
            local cached = getgenv()._ChessData.Cache.move
            if type(cached) == "string" and #cached >= 4 then
                return cached:sub(1,2), cached:sub(3,4)
            end
            return cached
        end
        
        -- 3. Call external APIs or local engine
        if selected == "SF17" or selected == "SF16" then
            local apis = { "https://chess-api.com/v1", "https://stockfish.online/api/s/v2.php" }
            
            for _, url in ipairs(apis) do
                local success, result = pcall(function()
                    return httpReq({
                        Url = url,
                        Method = "POST", 
                        Headers = {
                            ["Content-Type"] = "application/json",
                            ["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                        },
                        -- Request multiple variations to allow for intelligent mistakes
                        Body = HttpService:JSONEncode({
                            fen = fenValue,
                            depth = getgenv()._ChessOpts.apiDepth,
                            maxThinkingTime = getgenv()._ChessOpts.apiTime,
                            variants = 3
                        })
                    })
                end)
                
                if success and result and result.Success and result.StatusCode == 200 then
                    local data = HttpService:JSONDecode(result.Body)
                    local moves = {}

                    if data.continuationArr and #data.continuationArr > 0 then
                        moves = data.continuationArr
                    elseif data.bestmove then
                        table.insert(moves, data.bestmove)
                    elseif data.from and data.to then
                        table.insert(moves, data.from .. data.to)
                    end

                    if #moves > 0 then
                        -- Let EvaluateMove decide which move to play based on stealth settings
                        local from, to, quality = EvaluateMove(moves)
                        
                        -- Cache the actual best move, not the potentially flawed one
                        getgenv()._ChessData.Cache.fen = fenValue
                        getgenv()._ChessData.Cache.move = moves[1]
                        getgenv()._ChessData.Cache.time = tick()
                        
                        return from, to
                    end
                end
                task.wait(math.random(100, 500) / 1000)
            end
            
        elseif selected == "Local" then
            local success, result = pcall(function()
                local scripts = Players.LocalPlayer:WaitForChild("PlayerScripts", 3)
                if not scripts then return nil end
                local ai = scripts:FindFirstChild("AI")
                if not ai then return nil end
                local sunfish = ai:FindFirstChild("Sunfish")
                if not sunfish then return nil end
                local module = require(sunfish)
                return module:GetBestMove(fenValue, math.random(2000, 4000))
            end)
            
            if success and result then
                -- Wrap single move in a table for EvaluateMove
                return EvaluateMove({result})
            end
        end
        
        getgenv()._ChessData.Metrics.errors = getgenv()._ChessData.Metrics.errors + 1
        return nil
    end
    
    -- Executes the move provided by the engine.
    local function PlayMoveHuman(engine)
        local thinkingTime = GetHumanDelay("normal", HumanBehavior.GamePhase)
        SimulateMouseActivity()
        task.wait(thinkingTime)
        
        local from, to = GetBestMove(engine)
        
        task.wait(math.random(100, 250) / 1000) -- Reduced hand-eye delay
        
        local moveStr
        if from and to then
            moveStr = from .. to
        elseif from then
            moveStr = from  
        else
            return false
        end
        
        local success, result = pcall(function()
            return ReplicatedStorage.Chess.SubmitMove:InvokeServer(moveStr)
        end)
        
        if success then
            getgenv()._ChessData.Metrics.moves = getgenv()._ChessData.Metrics.moves + 1
            return true
        end
        
        return false
    end
    
    -- Manages the auto-play logic with a more robust retry and fallback system.
    local function PlayWithRetry()
        task.spawn(function()
            local primaryEngine = getgenv()._ChessOpts.engine
            local success = false

            -- 1. Try the primary engine first
            success = PlayMoveHuman(primaryEngine)
            if success then return end

            -- 2. If primary fails, create a list of fallback engines
            local fallbackEngines = {}
            for _, eng in ipairs(getgenv()._ChessData.Engines) do
                if eng ~= primaryEngine then
                    table.insert(fallbackEngines, eng)
                end
            end

            -- 3. Loop through fallback engines until one succeeds
            for i = 1, #fallbackEngines do
                local fallbackEngine = fallbackEngines[i]
                local frustrationDelay = i * (0.5 + math.random() * 0.5)
                task.wait(frustrationDelay)
                
                success = PlayMoveHuman(fallbackEngine)
                if success then return end
            end
        end)
    end
    
    -- Main auto-play event handling
    local function StartStealth()
        if not getgenv()._ChessOpts.active then
            CleanupConnections(getgenv()._ChessData.Conns)
            return
        end
        
        getgenv()._ChessData.Conns["moveResp"] = ReplicatedStorage.Chess.MovePlayedRemoteEvent.OnClientEvent:Connect(function(move, player)
            if player ~= Players.LocalPlayer then
                local reactionTime = math.random(400, 1000) / 1000 -- Reduced reaction time
                task.wait(reactionTime)
                PlayWithRetry()
            end
        end)
        
        getgenv()._ChessData.Conns["gameStart"] = ReplicatedStorage.Chess:WaitForChild("StartGameEvent").OnClientEvent:Connect(function()
            task.wait(math.random(1500, 4000) / 1000)
            PlayWithRetry()
        end)
        
        task.wait(1)
        PlayWithRetry()
    end
    
    -- UI Setup
    local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
    
    local Window = Rayfield:CreateWindow({
        Name = "Advanced Chess Bot v4.0",
        LoadingTitle = "Advanced Chess Bot",
        Theme = "Light",
        ToggleUIKeybind = "P"
    })
    
    -- Main Tab: Controls for engine and auto-play
    local MainTab = Window:CreateTab("Analysis", "brain")
    
    MainTab:CreateSection("Engine Settings")
    
    MainTab:CreateDropdown({
        Name = "Analysis Engine",
        Options = {"Stockfish 17", "Stockfish 16", "Local Analysis", "Cloud Eval"},
        CurrentOption = "Stockfish 17", 
        Flag = "Engine",
        Callback = function(opt)
            local engineMap = {["Stockfish 17"] = "SF17", ["Stockfish 16"] = "SF16", ["Local Analysis"] = "Local", ["Cloud Eval"] = "LC"}
            getgenv()._ChessOpts.engine = engineMap[opt[1]]
        end
    })
    
    MainTab:CreateSection("Practice Mode")
    
    MainTab:CreateToggle({
        Name = "Enable Practice Assistant",
        CurrentValue = false,
        Flag = "Practice",
        Callback = function(val)
            getgenv()._ChessOpts.active = val
            if val then StartStealth() else CleanupConnections(getgenv()._ChessData.Conns) end
        end
    })
    
    MainTab:CreateButton({ Name = "Suggest Move", Callback = PlayWithRetry })

    -- Stats Tab: Shows session performance
    local StatsTab = Window:CreateTab("Stats", "bar-chart")
    StatsTab:CreateSection("Session Statistics")
    local StatsLabel = StatsTab:CreateLabel("Loading statistics...")

    task.spawn(function()
        while task.wait(5) do
            local stats = getgenv()._ChessData.Metrics
            local uptime = math.floor(tick() - stats.start)
            local hours = math.floor(uptime / 3600)
            local minutes = math.floor((uptime % 3600) / 60)
            local seconds = uptime % 60
            
            StatsLabel:Set(string.format(
                "Moves Played: %d\nGames Won: %d\nAPI Errors: %d\nUptime: %02d:%02d:%02d\nCurrent Engine: %s",
                stats.moves, stats.wins, stats.errors, hours, minutes, seconds, getgenv()._ChessOpts.engine
            ))
        end
    end)
    
    -- Settings Tab: Fine-tune the bot's behavior
    local AdvancedTab = Window:CreateTab("Settings", "settings")
    
    AdvancedTab:CreateSection("API Engine Settings")

    -- Slider to control engine search depth
    AdvancedTab:CreateSlider({
        Name = "API Depth",
        Range = {10, 18},
        Increment = 1,
        CurrentValue = getgenv()._ChessOpts.apiDepth,
        Flag = "APIDepth",
        Callback = function(Value) getgenv()._ChessOpts.apiDepth = Value end,
    })

    -- Slider to control engine thinking time
    AdvancedTab:CreateSlider({
        Name = "API Max Thinking Time (ms)",
        Range = {20, 100},
        Increment = 10,
        CurrentValue = getgenv()._ChessOpts.apiTime,
        Flag = "APITime",
        Callback = function(Value) getgenv()._ChessOpts.apiTime = Value end,
    })

    AdvancedTab:CreateSection("Behavior Settings")
    
    AdvancedTab:CreateToggle({
        Name = "Human-like Timing",
        CurrentValue = StealthConfig.SimulateThinking,
        Flag = "HumanTiming",
        Callback = function(val)
            StealthConfig.SimulateThinking = val
            StealthConfig.VariableTiming = val
        end
    })
    
    -- Toggle for using the opening book
    AdvancedTab:CreateToggle({
        Name = "Use Opening Book",
        CurrentValue = StealthConfig.UseOpeningBook,
        Flag = "UseOpeningBook",
        Callback = function(val) StealthConfig.UseOpeningBook = val end
    })

    -- Toggle for enabling simulated mistakes
    AdvancedTab:CreateToggle({
        Name = "Natural Play Style", 
        CurrentValue = StealthConfig.AddInaccuracies,
        Flag = "Natural",
        Callback = function(val)
            StealthConfig.AddInaccuracies = val
            HumanBehavior.MoveProbabilities.Mistake = val and 0.05 or 0
            HumanBehavior.MoveProbabilities.Inaccuracy = val and 0.20 or 0
        end
    })
    
    AdvancedTab:CreateSlider({
        Name = "Response Variation",
        Range = {0.5, 3.0},
        Increment = 0.1,
        CurrentValue = 1.2,
        Flag = "Variation",
        Callback = function(val)
            for phase, times in pairs(HumanBehavior.ThinkingTimes) do
                times.min = times.min * val
                times.max = times.max * val
            end
        end
    })
    
    -- Background anti-detection monitoring
    task.spawn(function()
        while true do
            if getgenv()._ChessOpts.active then
                HumanBehavior.LastActivity = tick()
                if math.random() < 0.1 then
                    SimulateMouseActivity()
                end
            end
            task.wait(math.random(10, 30))
        end
    end)
    
    Rayfield:Notify({
        Title = "Analysis Ready",
        Content = "Advanced Chess Bot v4.0 loaded successfully.",
        Duration = 5,
        Image = "check"
    })
end

return ChessClubStealth()
